from LoRaRF import SX126x
import time
import sys
import signal

class LoRaTester:
    def __init__(self):
        self.lora = None
        self.running = True
        
    def signal_handler(self, signum, frame):
        """Handle Ctrl+C gracefully"""
        print("\nüõë Stopping LoRa test...")
        self.running = False
        if self.lora:
            try:
                self.lora.end()
                print("‚úÖ LoRa connection closed")
            except:
                pass
        sys.exit(0)
    
    def test_lora_connection(self):
        """‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ LoRa ‡πÅ‡∏ö‡∏ö‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î"""
        
        print("üîß Testing LoRa Connection...")
        print("=" * 50)
        
        try:
            # ‡∏™‡∏£‡πâ‡∏≤‡∏á LoRa object
            self.lora = SX126x()
            print("‚úÖ SX126x object created")
            
            # ‡∏•‡∏≠‡∏á‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠
            begin_result = self.lora.begin()
            print(f"‚úÖ LoRa.begin() successful - Result: {begin_result}")
            
            # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö methods ‡∏ó‡∏µ‡πà‡∏°‡∏µ
            self.print_available_methods()
            
            # ‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏≠‡πà‡∏≤‡∏ô‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞
            self.test_status_methods()
            
            # ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏Ñ‡πà‡∏≤‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô
            self.configure_basic_settings()
            
            return True
            
        except Exception as e:
            print(f"‚ùå Connection failed: {e}")
            print(f"üîç Error type: {type(e).__name__}")
            return False
    
    def print_available_methods(self):
        """‡πÅ‡∏™‡∏î‡∏á methods ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡πÉ‡∏ô LoRa object"""
        if not self.lora:
            return
            
        print("\nüìã Available Methods:")
        methods = [method for method in dir(self.lora) if not method.startswith('_')]
        
        # ‡∏à‡∏±‡∏î‡∏Å‡∏•‡∏∏‡πà‡∏° methods
        config_methods = [m for m in methods if any(word in m.lower() for word in ['set', 'config', 'frequency', 'power', 'spread'])]
        status_methods = [m for m in methods if any(word in m.lower() for word in ['get', 'status', 'rssi', 'snr'])]
        comm_methods = [m for m in methods if any(word in m.lower() for word in ['write', 'read', 'send', 'recv', 'available', 'transmit'])]
        
        if config_methods:
            print(f"  üîß Config: {config_methods}")
        if status_methods:
            print(f"  üìä Status: {status_methods}")
        if comm_methods:
            print(f"  üì° Communication: {comm_methods}")
        
        other_methods = [m for m in methods if m not in config_methods + status_methods + comm_methods]
        if other_methods:
            print(f"  üîπ Other: {other_methods}")
    
    def test_status_methods(self):
        """‡∏ó‡∏î‡∏™‡∏≠‡∏ö methods ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏≠‡πà‡∏≤‡∏ô‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞"""
        if not self.lora:
            return
            
        print("\nüîç Testing Status Methods:")
        
        status_methods = [
            ('getStatus', 'Get general status'),
            ('status', 'Get status'),
            ('getRSSI', 'Get RSSI'),
            ('getSNR', 'Get SNR'),
            ('getFrequency', 'Get frequency'),
            ('getSpreadingFactor', 'Get spreading factor'),
            ('getBandwidth', 'Get bandwidth')
        ]
        
        for method_name, description in status_methods:
            try:
                if hasattr(self.lora, method_name):
                    method = getattr(self.lora, method_name)
                    result = method()
                    print(f"  ‚úÖ {description}: {result}")
                else:
                    print(f"  ‚ö†Ô∏è {method_name} not available")
            except Exception as e:
                print(f"  ‚ùå {description} error: {e}")
    
    def configure_basic_settings(self):
        """‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏Ñ‡πà‡∏≤‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö LoRa"""
        if not self.lora:
            return
            
        print("\n‚öôÔ∏è Configuring Basic Settings:")
        
        configs = [
            ('setFrequency', 915.0, 'Frequency (MHz)'),
            ('setSpreadingFactor', 7, 'Spreading Factor'),
            ('setBandwidth', 9600, 'Bandwidth (Hz)'),
            ('setCodeRate', 5, 'Code Rate'),
            ('setPreambleLength', 8, 'Preamble Length'),
            ('setTxPower', 14, 'TX Power (dBm)'),
            ('setSyncWord', 0x12, 'Sync Word')
        ]
        
        for method_name, value, description in configs:
            try:
                if hasattr(self.lora, method_name):
                    method = getattr(self.lora, method_name)
                    result = method(value)
                    print(f"  ‚úÖ {description}: {value} - Result: {result}")
                else:
                    print(f"  ‚ö†Ô∏è {method_name} not available")
            except Exception as e:
                print(f"  ‚ùå {description} config error: {e}")
    
    def test_simple_send(self, message="Hello LoRa!"):
        """‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏û‡∏£‡πâ‡∏≠‡∏° error handling ‡∏ó‡∏µ‡πà‡∏î‡∏µ"""
        
        if not self.test_lora_connection():
            return False
        
        print(f"\nüì§ Testing Send Function:")
        print(f"üìù Message: '{message}'")
        print("=" * 50)
        
        # ‡πÅ‡∏õ‡∏•‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏õ‡πá‡∏ô‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏ï‡πà‡∏≤‡∏á‡πÜ
        message_str = str(message)
        message_bytes = message_str.encode('utf-8')
        message_list = list(message_bytes)
        
        print(f"üìä Data formats:")
        print(f"  String: '{message_str}'")
        print(f"  Bytes: {message_bytes}")
        print(f"  List: {message_list}")
        
        # ‡∏•‡∏≠‡∏á‡∏™‡πà‡∏á‡∏î‡πâ‡∏ß‡∏¢‡∏ß‡∏¥‡∏ò‡∏µ‡∏ï‡πà‡∏≤‡∏á‡πÜ
        send_methods = [
            ('write', message_list, len(message_list), 'Write with list and length'),
            ('write', message_list, None, 'Write with list only'),
            ('write', message_bytes, None, 'Write with bytes'),
            ('write', message_str, None, 'Write with string'),
            ('send', message_list, len(message_list), 'Send with list and length'),
            ('send', message_list, None, 'Send with list only'),
            ('transmit', message_list, len(message_list), 'Transmit with list and length')
        ]
        
        success_count = 0
        
        for method_name, data, length, description in send_methods:
            if not hasattr(self.lora, method_name):
                print(f"  ‚ö†Ô∏è {description}: Method not available")
                continue
                
            try:
                method = getattr(self.lora, method_name)
                
                # ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ method ‡∏ï‡∏≤‡∏°‡∏à‡∏≥‡∏ô‡∏ß‡∏ô parameters
                if length is not None:
                    result = method(data, length)
                else:
                    result = method(data)
                
                print(f"  ‚úÖ {description}: Success - Result: {result}")
                success_count += 1
                
                # ‡∏£‡∏≠‡∏≠‡∏µ‡∏Å‡∏™‡∏±‡∏Å‡∏Ñ‡∏£‡∏π‡πà‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô
                time.sleep(0.1)
                
            except Exception as e:
                print(f"  ‚ùå {description}: Error - {e}")
        
        print(f"\nüìä Send Summary: {success_count}/{len(send_methods)} methods successful")
        return success_count > 0
    
    def test_simple_receive(self, timeout=60):
        """‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏û‡∏£‡πâ‡∏≠‡∏° timeout ‡πÅ‡∏•‡∏∞ error handling"""
        
        if not self.test_lora_connection():
            return
        
        print(f"\nüì° Testing Receive Function:")
        print(f"‚è∞ Timeout: {timeout} seconds")
        print("=" * 50)
        
        # ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ signal handler ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Ctrl+C
        signal.signal(signal.SIGINT, self.signal_handler)
        
        # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö receive methods
        receive_methods = []
        method_names = ['available', 'read', 'readBytes', 'receive', 'listen']
        
        for method_name in method_names:
            if hasattr(self.lora, method_name):
                receive_methods.append(method_name)
        
        print(f"üìã Available receive methods: {receive_methods}")
        
        # ‡πÄ‡∏£‡∏¥‡πà‡∏° receive mode ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ
        if 'receive' in receive_methods:
            try:
                self.lora.receive()
                print("üì° Set to receive mode")
            except Exception as e:
                print(f"‚ö†Ô∏è Receive mode error: {e}")
        
        start_time = time.time()
        loop_count = 0
        
        print(f"\nüéß Listening for messages... (Press Ctrl+C to stop)")
        
        while self.running and (time.time() - start_time) < timeout:
            try:
                loop_count += 1
                data_received = False
                
                # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏°‡∏µ
                if 'available' in receive_methods:
                    try:
                        available_bytes = self.lora.available()
                        
                        if available_bytes and available_bytes > 0:
                            print(f"\nüì® Data available: {available_bytes} bytes")
                            data_received = True
                            
                            # ‡∏•‡∏≠‡∏á‡∏≠‡πà‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏î‡πâ‡∏ß‡∏¢‡∏ß‡∏¥‡∏ò‡∏µ‡∏ï‡πà‡∏≤‡∏á‡πÜ
                            self.try_read_data(available_bytes)
                            
                    except Exception as e:
                        if loop_count % 10 == 1:  # ‡πÅ‡∏™‡∏î‡∏á error ‡∏ó‡∏∏‡∏Å 10 loops
                            print(f"‚ö†Ô∏è Available check error: {e}")
                
                # ‡∏•‡∏≠‡∏á‡∏≠‡πà‡∏≤‡∏ô‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ available method
                elif 'read' in receive_methods:
                    try:
                        data = self.lora.read()
                        if data:
                            print(f"\nüì® Direct read data: {data}")
                            self.decode_received_data(data)
                            data_received = True
                    except Exception as e:
                        if loop_count % 10 == 1:
                            print(f"‚ö†Ô∏è Direct read error: {e}")
                
                # ‡πÅ‡∏™‡∏î‡∏á‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏ó‡∏∏‡∏Å 5 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
                if loop_count % 5 == 0 and not data_received:
                    elapsed = int(time.time() - start_time)
                    remaining = timeout - elapsed
                    print(f"‚è≥ Listening... ({elapsed}s elapsed, {remaining}s remaining)")
                
                time.sleep(1)
                
            except KeyboardInterrupt:
                self.signal_handler(None, None)
                break
            except Exception as e:
                print(f"‚ö†Ô∏è Loop error: {e}")
                time.sleep(1)
        
        print(f"\nüèÅ Receive test completed after {int(time.time() - start_time)} seconds")
    
    def try_read_data(self, available_bytes):
        """‡∏•‡∏≠‡∏á‡∏≠‡πà‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏î‡πâ‡∏ß‡∏¢‡∏ß‡∏¥‡∏ò‡∏µ‡∏ï‡πà‡∏≤‡∏á‡πÜ"""
        
        read_methods = [
            ('read', None, 'Basic read'),
            ('read', available_bytes, 'Read with length'),
            ('readBytes', available_bytes, 'Read bytes with length')
        ]
        
        data = None
        
        for method_name, param, description in read_methods:
            if not hasattr(self.lora, method_name):
                continue
                
            try:
                method = getattr(self.lora, method_name)
                
                if param is not None:
                    result = method(param)
                else:
                    result = method()
                
                print(f"  üì• {description}: {result} (type: {type(result).__name__})")
                
                if result is not None:
                    data = result
                    break
                    
            except Exception as e:
                print(f"  ‚ùå {description} error: {e}")
        
        # ‡∏ñ‡∏≠‡∏î‡∏£‡∏´‡∏±‡∏™‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏≠‡πà‡∏≤‡∏ô‡πÑ‡∏î‡πâ
        if data is not None:
            self.decode_received_data(data)
        else:
            print("  üì≠ No data could be read")
    
    def decode_received_data(self, data):
        """‡∏ñ‡∏≠‡∏î‡∏£‡∏´‡∏±‡∏™‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏£‡∏±‡∏ö‡∏°‡∏≤‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏Ñ‡∏£‡∏≠‡∏ö‡∏Ñ‡∏•‡∏∏‡∏°"""
        
        print(f"\nüîç Decoding received data:")
        print(f"  üìä Raw data: {data}")
        print(f"  üìä Data type: {type(data).__name__}")
        
        try:
            if isinstance(data, (list, tuple)):
                if len(data) > 0:
                    print(f"  üìä List/Tuple length: {len(data)}")
                    
                    # ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏î‡∏¥‡∏ö
                    if len(data) <= 20:
                        print(f"  üìä Raw values: {data}")
                    else:
                        print(f"  üìä Raw values (first 20): {data[:20]}...")
                    
                    # ‡∏•‡∏≠‡∏á‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô string
                    try:
                        # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô valid bytes ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
                        valid_bytes = all(isinstance(x, int) and 0 <= x <= 255 for x in data)
                        
                        if valid_bytes:
                            byte_data = bytes(data)
                            
                            # ‡∏•‡∏≠‡∏á UTF-8
                            try:
                                message = byte_data.decode('utf-8')
                                print(f"  üî§ UTF-8 decoded: '{message}'")
                            except UnicodeDecodeError:
                                # ‡∏•‡∏≠‡∏á ASCII
                                try:
                                    message = byte_data.decode('ascii', 'ignore')
                                    print(f"  üî§ ASCII decoded: '{message}'")
                                except:
                                    pass
                            
                            # ‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏õ‡πá‡∏ô hex
                            hex_data = byte_data.hex()
                            print(f"  üî¢ Hex: {hex_data}")
                            
                            # ‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏õ‡πá‡∏ô printable characters
                            printable = ''.join(chr(b) if 32 <= b <= 126 else f'\\x{b:02x}' for b in data)
                            print(f"  üìù Printable: '{printable}'")
                        else:
                            print(f"  ‚ö†Ô∏è Not valid byte data")
                    except Exception as decode_error:
                        print(f"  ‚ùå Decode error: {decode_error}")
                else:
                    print(f"  üì≠ Empty list/tuple")
                    
            elif isinstance(data, int):
                print(f"  üìä Integer value: {data}")
                if data != 0:
                    if 0 <= data <= 255:
                        print(f"  üî¢ Hex: 0x{data:02x}")
                        if 32 <= data <= 126:
                            print(f"  üî§ ASCII char: '{chr(data)}'")
                else:
                    print(f"  üì≠ Zero value")
                    
            elif isinstance(data, bytes):
                print(f"  üìä Bytes length: {len(data)}")
                if len(data) > 0:
                    print(f"  üî¢ Hex: {data.hex()}")
                    try:
                        message = data.decode('utf-8')
                        print(f"  üî§ UTF-8 decoded: '{message}'")
                    except:
                        try:
                            message = data.decode('ascii', 'ignore')
                            print(f"  üî§ ASCII decoded: '{message}'")
                        except:
                            pass
                else:
                    print(f"  üì≠ Empty bytes")
                    
            elif isinstance(data, str):
                print(f"  üî§ String message: '{data}'")
                print(f"  üìä String length: {len(data)}")
                
            else:
                print(f"  ‚ùì Unknown data type: {type(data).__name__}")
                print(f"  üìä String representation: {str(data)}")
                
        except Exception as e:
            print(f"  ‚ùå Decode error: {e}")
    
    def run_interactive_test(self):
        """‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡πÅ‡∏ö‡∏ö interactive"""
        
        print("üöÄ LoRa Interactive Test Mode")
        print("=" * 50)
        
        while True:
            print("\nSelect test mode:")
            print("1. Test Connection")
            print("2. Send Message")
            print("3. Receive Messages")
            print("4. Send Custom Message")
            print("5. Exit")
            
            try:
                choice = input("\nEnter choice (1-5): ").strip()
                
                if choice == '1':
                    self.test_lora_connection()
                elif choice == '2':
                    self.test_simple_send()
                elif choice == '3':
                    timeout = input("Enter timeout in seconds (default 60): ").strip()
                    timeout = int(timeout) if timeout.isdigit() else 60
                    self.test_simple_receive(timeout)
                elif choice == '4':
                    message = input("Enter message to send: ").strip()
                    if message:
                        self.test_simple_send(message)
                    else:
                        print("Empty message!")
                elif choice == '5':
                    break
                else:
                    print("Invalid choice!")
                    
            except KeyboardInterrupt:
                print("\nüõë Interrupted by user")
                break
            except Exception as e:
                print(f"‚ùå Error: {e}")
        
        print("üëã Goodbye!")


def main():
    """Main function with improved argument handling"""
    
    tester = LoRaTester()
    
    if len(sys.argv) < 2:
        print("üöÄ LoRa Testing Tool")
        print("=" * 50)
        print("Usage:")
        print("  python lora_test.py test              - Test connection only")
        print("  python lora_test.py send              - Test sending default message")
        print("  python lora_test.py send 'message'    - Test sending custom message")
        print("  python lora_test.py receive           - Test receiving (60s timeout)")
        print("  python lora_test.py receive 30        - Test receiving (30s timeout)")
        print("  python lora_test.py interactive       - Interactive mode")
        print("  python lora_test.py all               - Run all tests")
        return
    
    command = sys.argv[1].lower()
    
    try:
        if command == "test":
            tester.test_lora_connection()
            
        elif command == "send":
            message = sys.argv[2] if len(sys.argv) > 2 else "Hello LoRa!"
            tester.test_simple_send(message)
            
        elif command == "receive":
            timeout = int(sys.argv[2]) if len(sys.argv) > 2 and sys.argv[2].isdigit() else 60
            tester.test_simple_receive(timeout)
            
        elif command == "interactive":
            tester.run_interactive_test()
            
        elif command == "all":
            print("üîÑ Running all tests...")
            print("\n" + "="*50)
            print("TEST 1: CONNECTION")
            print("="*50)
            if tester.test_lora_connection():
                print("\n" + "="*50)
                print("TEST 2: SENDING")
                print("="*50)
                tester.test_simple_send()
                
                print("\n" + "="*50)
                print("TEST 3: RECEIVING (10 seconds)")
                print("="*50)
                tester.test_simple_receive(10)
            
        else:
            print(f"‚ùå Invalid command: {command}")
            print("Use 'python lora_test.py' without arguments to see usage")
            
    except KeyboardInterrupt:
        print("\nüõë Test interrupted by user")
    except Exception as e:
        print(f"‚ùå Unexpected error: {e}")
        print(f"üîç Error type: {type(e).__name__}")


if __name__ == "__main__":
    main()